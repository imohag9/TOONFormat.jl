var documenterSearchIndex = {"docs":
[{"location":"guide/#User-Guide","page":"User Guide","title":"User Guide","text":"This guide details the specific features and configuration options available in TOONFormat.jl.","category":"section"},{"location":"guide/#Decoding","page":"User Guide","title":"Decoding","text":"The decode function parses TOON strings into native Julia types. By default, it produces OrderedDicts to preserve key order.","category":"section"},{"location":"guide/#Strict-Mode","page":"User Guide","title":"Strict Mode","text":"By default, decoding is strict. This ensures data integrity by enforcing:\n\nArray Counts: The [N] header must match the actual number of items.\nIndentation: Lines must align exactly with the indent_size.\nTabular Width: Rows must match the number of fields in the header.\n\nusing TOONFormat\n\n# This will throw a ParseError because [3] is declared, but only 2 items exist.\nbad_data = \"\"\"\nitems[3]:\n  1, 2\n\"\"\"\n\ntry\n    TOONFormat.decode(bad_data)\ncatch e\n    println(e) # ParseError: Inline array length mismatch...\nend\n\n# Disable strict mode to recover data\ndata = TOONFormat.decode(bad_data; strict=false)","category":"section"},{"location":"guide/#Path-Expansion-(Configuration-Mode)","page":"User Guide","title":"Path Expansion (Configuration Mode)","text":"TOON is excellent for configuration files. The Path Expansion feature allows you to write flat, dotted keys that parse into deeply nested objects.\n\nexpand_paths=\"off\" (Default): Keys are read exactly as written.\nexpand_paths=\"safe\": Keys containing dots are split into nested dictionaries.\n\nInput:\n\ndatabase.primary.host: 10.0.0.1\ndatabase.primary.port: 5432\n\nUsage:\n\n# Default behavior\nd1 = TOONFormat.decode(input)\n# d1[\"database.primary.host\"] == \"10.0.0.1\"\n\n# With expansion\nd2 = TOONFormat.decode(input; expand_paths=\"safe\")\n# d2[\"database\"][\"primary\"][\"host\"] == \"10.0.0.1\"\n\nwarning: Conflicts\nIn strict mode, if a path expansion conflicts with an existing value (e.g., a: 1 vs a.b: 2), a ParseError is thrown. In non-strict mode, the last value wins or merges strictly.\n\n","category":"section"},{"location":"guide/#Encoding","page":"User Guide","title":"Encoding","text":"The encode function serializes Julia data. It performs automatic optimization to reduce output size.","category":"section"},{"location":"guide/#Tabular-Optimization","page":"User Guide","title":"Tabular Optimization","text":"The encoder automatically analyzes arrays of dictionaries (Vector{<:AbstractDict}). If all dictionaries in the array share the exact same keys and contain primitive values, it switches to Tabular Format.\n\ndata = [\n    Dict(\"x\" => 1, \"y\" => 2),\n    Dict(\"x\" => 3, \"y\" => 4)\n]\n\nprint(TOONFormat.encode(data))\n\nOutput:\n\n[2]{x,y}:\n  1,2\n  3,4","category":"section"},{"location":"guide/#Key-Folding","page":"User Guide","title":"Key Folding","text":"Key folding is the inverse of path expansion. It flattens nested dictionaries into dotted keys to reduce indentation depth and file line count.\n\nkey_folding=\"off\" (Default): Standard nested objects.\nkey_folding=\"safe\": Collapses keys only if they are valid identifiers (alphanumeric).\n\nconfig = Dict(\n    \"server\" => Dict(\n        \"http\" => Dict(\"port\" => 80),\n        \"ssh\"  => Dict(\"port\" => 22)\n    )\n)\n\nprint(TOONFormat.encode(config; key_folding=\"safe\"))\n\nOutput:\n\nserver.http.port: 80\nserver.ssh.port: 22\n\nYou can limit how deep the folding goes using the flatten_depth argument.","category":"section"},{"location":"guide/#Custom-Delimiters","page":"User Guide","title":"Custom Delimiters","text":"If your data contains many commas (e.g., text descriptions), you can change the delimiter to a pipe | or tab \\t to avoid excessive quoting.\n\ndata = [\"Hello, World\", \"Coordinates: 1,2\"]\n\n# Default (uses quotes because of commas)\n# [2]: \"Hello, World\", \"Coordinates: 1,2\"\n\n# With Pipe Delimiter\nprint(TOONFormat.encode(data; delimiter='|'))\n\nOutput:\n\n[2|]: Hello, World|Coordinates: 1,2\n\n","category":"section"},{"location":"guide/#Type-Mapping","page":"User Guide","title":"Type Mapping","text":"TOONFormat.jl maps TOON types to standard Julia types:\n\nTOON Type Julia Type Notes\nObject OrderedDict{String, Any} Preserves insertion order.\nArray Vector{Any} Can be heterogeneous.\nString String Handles escaping automatically.\nNumber Int or Float64 Distinction is preserved.\nBoolean Bool true / false.\nNull Nothing null maps to nothing.","category":"section"},{"location":"guide/#Julia-Specific-Types","page":"User Guide","title":"Julia-Specific Types","text":"The encoder handles some Julia specific types gracefully:\n\nSymbol: Converted to String.\nDate / DateTime: Converted to ISO Strings.\nSet / Tuple: Converted to Arrays.\nNaN / Inf: Converted to null (as per JSON/TOON spec).","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This section provides an automatically generated reference for all exported functions and types in the TOONFormat module.","category":"section"},{"location":"api/#TOONFormat.DecoderState","page":"API Reference","title":"TOONFormat.DecoderState","text":"DecoderState\n\nMaintains the internal state during the decoding process.\n\nFields\n\nlines::Vector{String}: The input document split into lines.\ncurrent_line_idx::Int: The current 1-based line index being parsed.\nopts::TOONOptions: Configuration options controlling the decoder's behavior (strictness, indentation, etc.).\n\n\n\n\n\n","category":"type"},{"location":"api/#TOONFormat.EncoderState","page":"API Reference","title":"TOONFormat.EncoderState","text":"EncoderState\n\nMaintains the internal state during the encoding process.\n\nFields\n\nio::IO: The output stream where the TOON document is written.\nopts::TOONOptions: Configuration options (indent size, delimiter, etc.).\ndepth::Int: The current indentation depth level (0-indexed).\nactive_delimiter::Char: The delimiter used in the current array scope, used for decision making on quoting.\n\n\n\n\n\n","category":"type"},{"location":"api/#TOONFormat.ParseError","page":"API Reference","title":"TOONFormat.ParseError","text":"ParseError <: Exception\n\nException thrown when the TOON decoder encounters invalid syntax or structural issues.\n\nFields\n\nmsg::String: A description of the error.\nline::Int: The line number in the source string where the error occurred (0 if unknown or global).\n\n\n\n\n\n","category":"type"},{"location":"api/#TOONFormat.TOONOptions","page":"API Reference","title":"TOONFormat.TOONOptions","text":"TOONOptions\n\nConfiguration for TOON encoding and decoding.\n\n\n\n\n\n","category":"type"},{"location":"api/#TOONFormat.canonical_number-Tuple{Integer}","page":"API Reference","title":"TOONFormat.canonical_number","text":"canonical_number(x::Real) -> String\n\nEncodes numbers according to TOON Spec ยง2:\n\nNo exponent notation (1e6 -> 1000000).\nNo leading zeros.\nNo trailing zeros in fractional part.\n-0 normalized to 0.\nFinite numbers only (NaN/Inf -> null, handled elsewhere).\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.decode-Tuple{AbstractString}","page":"API Reference","title":"TOONFormat.decode","text":"decode(str::AbstractString; kw...) -> Any\n\nDecodes a TOON-formatted string into native Julia data structures.\n\nReturn Values\n\nReturns a OrderedDict (ordered dictionary), Vector, or primitive value (String, Number, Bool, Nothing)  depending on the root element of the TOON document.\n\nKeywords\n\nstrict::Bool=true: If true, enforces strict indentation rules and array length checks.\nexpand_paths::String=\"off\": Controls dot-notation key expansion (e.g., \"a.b: 1\" -> Dict(\"a\" => Dict(\"b\" => 1))).   Options are \"off\" or \"safe\".\nindent_size::Int=2: The number of spaces used for one level of indentation.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.deep_merge!-Tuple{AbstractDict, AbstractDict}","page":"API Reference","title":"TOONFormat.deep_merge!","text":"deep_merge!(target, source)\n\nRecursively merges source dict into target dict using mergewith!.\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.encode","page":"API Reference","title":"TOONFormat.encode","text":"encode(io::IO, data, opts::TOONOptions=DEFAULT_OPTS)\n\nMain entry point for encoding data to TOON into an IO stream.\n\n\n\n\n\n","category":"function"},{"location":"api/#TOONFormat.encode-Tuple{Any}","page":"API Reference","title":"TOONFormat.encode","text":"encode(data; kw...) -> String\n\nSerializes a Julia data structure into the TOON format.\n\nArguments\n\ndata: The data to encode. Supported types include Dicts, Arrays, Strings, Numbers, Bools, nothing, and structs supported by JSON.lower.\n\nKeywords\n\nindent_size::Int=2: Number of spaces per indentation level.\ndelimiter::Char=',': The preferred delimiter for arrays (e.g., ,, |, ).\nkey_folding::String=\"off\": If \"safe\", collapses nested objects into dotted keys where possible (e.g., server.port: 80).\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.encode_folded_dict-Tuple{TOONFormat.EncoderState, AbstractDict, String}","page":"API Reference","title":"TOONFormat.encode_folded_dict","text":"encode_folded_dict(state, val, prefix)\n\nRecursively flattens nested dictionaries into dotted keys until a terminal value (primitive, array, non-foldable key, or depth limit) is reached.\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.encode_key-Tuple{AbstractString}","page":"API Reference","title":"TOONFormat.encode_key","text":"encode_key(k::AbstractString) -> String\n\nEncodes object keys. Spec ยง7.3: Unquoted if ^[A-Za-z][A-Za-z0-9.]*\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.is_foldable_key-Tuple{AbstractString}","page":"API Reference","title":"TOONFormat.is_foldable_key","text":"is_foldable_key(k)\n\nReturns true if k contains only characters valid for an unquoted TOON key segment  (alphanumeric + underscore). If it contains dots or special chars, it shouldn't be folded.\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.parse_header_line-Tuple{AbstractString}","page":"API Reference","title":"TOONFormat.parse_header_line","text":"parse_header_line(line::AbstractString) -> Union{HeaderInfo, Nothing}\n\nParses a header line like key[N]: or key[N]{f1,f2}:.  Returns nothing if not a valid header.\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.set_value_with_path!-Tuple{OrderedCollections.OrderedDict, AbstractString, Any, TOONOptions}","page":"API Reference","title":"TOONFormat.set_value_with_path!","text":"set_value_with_path!(obj, key, value, opts; is_quoted=false)\n\nSets a value in the object, expanding the key into nested objects if opts.expand_paths is enabled. Also handles conflicts and merging.\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.should_quote-Tuple{AbstractString, Char, Char}","page":"API Reference","title":"TOONFormat.should_quote","text":"should_quote(s::AbstractString, active_delim::Char, doc_delim::Char) -> Bool\n\nDetermines if a string MUST be quoted according to TOON Spec ยง7.2.\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.spec_version-Tuple{}","page":"API Reference","title":"TOONFormat.spec_version","text":"spec_version() -> String\n\nReturn the version of the TOONFormat specification that this implementation supports.\n\n\n\n\n\n","category":"method"},{"location":"api/#TOONFormat.write_indent-Tuple{TOONFormat.EncoderState}","page":"API Reference","title":"TOONFormat.write_indent","text":"write_indent(state::EncoderState)\n\nWrites indentation based on current depth and indent_size.\n\n\n\n\n\n","category":"method"},{"location":"#TOONFormat.jl","page":"Home","title":"TOONFormat.jl","text":"TOONFormat.jl is a pure Julia implementation of TOON (The Object-Oriented Notation). It is a modern data serialization format designed to be a strict, type-safe, and dense alternative to JSON and YAML.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"TOON combines the best features of existing formats:\n\nJSON's Structure: It maps directly to Dictionaries, Arrays, and Primitives.\nYAML's Readability: It supports clean syntax, key folding, and comments.\nCSV's Density: It automatically compresses arrays of objects into tabular headers and rows.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package is available for Julia 1.11+.\n\nusing Pkg\nPkg.add(\"TOONFormat\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Encoding-(Writing)","page":"Home","title":"Encoding (Writing)","text":"TOONFormat automatically detects if your data can be compressed into a table.\n\nusing TOONFormat\n\ndata = Dict(\n    \"users\" => [\n        Dict(\"id\" => 1, \"name\" => \"Alice\", \"role\" => \"admin\"),\n        Dict(\"id\" => 2, \"name\" => \"Bob\", \"role\" => \"dev\")\n    ]\n)\n\n# Output is compact and type-safe\nprintln(TOONFormat.encode(data))\n\nOutput:\n\nusers[2]{id,name,role}:\n  1,Alice,admin\n  2,Bob,dev","category":"section"},{"location":"#Decoding-(Reading)","page":"Home","title":"Decoding (Reading)","text":"toon_str = \"\"\"\nserver.host: localhost\nserver.port: 8080\n\"\"\"\n\n# \"safe\" expansion turns dot-notation into nested Dicts\nconfig = TOONFormat.decode(toon_str; expand_paths=\"safe\")\n\nprintln(config[\"server\"][\"port\"]) # 8080\n\nCheck out the documentationfor deep dives into features like Key Folding, Tabular Arrays, and Strict Mode.","category":"section"}]
}
